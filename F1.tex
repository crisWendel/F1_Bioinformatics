\documentclass{article}
\usepackage[latin1]{inputenc}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{color}
\usepackage[dvipsnames]{xcolor}
\usepackage[english]{babel}
\usepackage{biblatex}
\usepackage{pifont}
\usepackage[usestackEOL]{stackengine}
\usepackage{lmodern}



\title{\huge\textbf{Master F1 Internship - Bioinformatics}}
\author{\LARGE Christine Liao}
\date{\parbox{\linewidth}{\centering%
  \today \endgraf
  \bigskip
  \vspace{10cm}
  \LARGE Supervisor:\ Dr. Konrad F\"orstner \endgraf
  Core Unit Systems Medicine\endgraf
  Julius Maximilian University - W\"urzburg}}
 

\begin{document}

\maketitle
\newpage
  \pagenumbering{roman}
  \tableofcontents
\newpage  
\pagenumbering{arabic}



\section{Unix Shell}

Unix is an operating system (OS) developed in the '60s. An OS is a group of programs which makes the computer work. Each program performs limited function with a unified file system.\\
\\
Unix systems also have a graphical user interface (GUI). An interface is a place that allows 2 things to communicate; in this case, human and machine. GUI allows user to communicate with the machine by using visual language. For example, the disk icon indicates that upon clicking, the file will be saved. Another example of graphical operating system is the Microsoft Windows.\\
\\
Command line interface (CLI) is another way to communicate with the machine by using commands. The purpose of this F1 internship is to learn the basics of how CLI works in Unix. To do this, Unix shell is used. Unix shell is a command-line interpreter, which allows users to enter commands as text and then executes the operation.\\
\\
Unix shell is both command language and a scripting programming language. A shell script is often used to control the operating system. A script is a series of commands that is often used, and can be saved in a text editor. A text editor is a type of computer program the edits plain text. An example of such programs is the "notepad" software. Text editors are part of the operating systems packages, and can be used to change configuration files and programming language source code. In this chapter, nano text editor is used. \\
\\
The terminal emulator (or simply the terminal) is just the window that opens up and the shell is the program that runs behind to interpret the commands typed in the window. 

\subsection{\textbf{Definitions}}


\texttt{shell} ~ language to run other programs using command-line interface instead of GUI.\\
\\
\texttt{command-line interface} ~ uses read-evaluate-print loop (REPL) to interpret when we type a command and press the Enter key: it reads, executes and prints the output\\
\\
\texttt{bash} ~	a default shell.\\
\\
\texttt{kernel} ~ core of the computer's operating system, where controls everything. \\
\\
\texttt{bin} ~ a folder that stores built-in programs.\\
\\
\texttt{temp} ~ a folder that stores temporary files.\\
\\
\texttt{flag} ~ adds a marker to file or directory to show what they are.\\
\\
\texttt{nano	} ~	text editor for Unix systems, creates only plain character data. You can save text file or commands. \\
\\
\texttt{argument} ~	tells the command what to operate on (file or folder).\\
\\
\texttt{input file} ~ the first file during an execution command. \\
\\
\texttt{output file} ~ the second file during an execution command.\\
\\
\texttt{pipe} ~ a vertical line,|, separating two commands, where the output of the command on the left side will be the input for the command on the right side.\\
\\
\texttt{loop} ~ a set of commands that allows an operation to be executed repetitively, automatically.\\
\\
\texttt{iteration} ~ each time the loop completes the operation is called iteration.\\  
\\
\texttt{grep} ~ global/regular expression/print. It is a sequence of operations. It finds and then prints lines in a text that contains the pattern that we are looking for. A pattern can be a word.\\
\\
\subsection{\textbf{Symbols}}
\texttt{\$}~
a prompt.\\
\texttt{/}~	root directory when placed in front of file or folder; separator if between names.\\
\texttt{\~{}} ~	current user's directory.\\
\texttt{*} ~ wildcard\\
\texttt{?} ~	 wildcard\\
\texttt{|} ~	 pipe\\
\texttt{>} ~ a prompt when writing commands in a loop. This symbol is to show that the commands are not complete yet.  In Shell, it can also mean "to redirect". \\ 
\texttt{\$} ~ can also assign something to become a variable inside a loop. For example, \$filename means to treat the variable as a variable name and substitute its value in its place, rather than treat it as a text or as a command.\\
\\
\subsection{\textbf{Commands}}
\subsubsection{\small\textsl{How to navigate around shell}}
\texttt{\$ ls} ~ lists content of a directory.\\ 
\texttt{\$ man ls} ~ lists the manual.\\ 
\texttt{\$ pwd}} ~ prints working directory.\\
\texttt{\$ Ctrl-l} ~ cleans the screen.\\ 
\texttt{\$ PS1 ='\$ '}} ~ starts the prompt with only \$ sign.\\  
\texttt{\$ ls -F}	 ~	adds trailing "/" to the names of directories. It is a "Flag" (option).\\ 
\texttt{\$ man ls} ~	to see many other flags (Mac only).\\ 
\texttt{\$ ls -l} ~ shows file/directory names, size and time of last modification.\\ 
\texttt{\$ ls -l-h} ~ makes file size more readable to 2 digits.\\ 
\texttt{\$ ls -R	} ~	lists directories and sub-directories.\\ 
\texttt{\$ ls -R -t} ~ directories are sorted by time and last change.\\ 
\texttt{\$ ls -F} ~  lists content by showing what kind of file they are.\\
\texttt{\$ cd Desktop} ~  changes directory to Desktop.\\
\texttt{\$ cd Folder} ~	changes directory into a folder, subdirectory. \\
\texttt{\$ cd File} ~ changes directory into a file, sub-subdirectory. \\
\texttt{\$ cd ..	} ~	goes one level up of the directory (in the direction of right to left, ie. closer to Home).\\
\texttt{\$ cd}} ~ returns to home directory. \\


\subsubsection{\small\textsl{How to create, copy and delete}}
\texttt{\$ mkdir thesis} ~ creates a directory (folder) called thesis.\\
\texttt{\$ touch file.txt} ~	creates a file.\\
\texttt{\$ nano draft.txt} ~	creates a file in nano. To exit from Nano back to Unix shell, type Ctrl-X, Y, Enter (Mac).\\
\texttt{\$ rm draft.txt} ~ deletes the file PERMANENTLY. There is no trash in UNIX shell.\\
\texttt{\$ rm -r thesis} ~ deletes folder and its content PERMANENTLY.\\
\texttt{\$ mv thesis/draft.txt} ~	moves the file into a directory.\\
\texttt{\$ mv thesis/draft.txt thesis/quotes.txt} ~  file name is changed to quotes.txt. \\
\texttt{\$ cp fileOne.txt fileTwo.txt} ~	copies the content of the first file into the second file.\\
\texttt{\$ mv *.txt} ~	moves all files ending .txt to original home directory.\\
\texttt{\$ cp one.txt two.txt. thesis} ~ copies the two files into a folder called thesis.\\
\texttt{\$ ls -R -t} ~ displays directories recursively (lists their sub-directories in  alphabetical order).\\
\texttt{-t} ~ lists things by the time of the last change.\\
\texttt{\$ rm -i} ~  -i is a flag, for \textit{interactive}, prompts the user whether to proceed with the delete operation.\\

\subsubsection{\small\textsl{How to count, sort and pipe}}
\texttt{\$ wc *.pdb} ~ word counts (number of lines, words, characters in file). \\
\texttt{\$ p*.pdb} ~	any file starting with "p" letter that is a pdb file.\\
\texttt{\$ p?.pdb} ~ any file that has only letter after "p", eg. pi.pdb.\\
\texttt{\$ p*.p?*} ~	 any file starting with "p" and ends with "." or "p" and at least one more character.\\
\texttt{\$ wc -l*.pdb} ~	 counts number of lines.\\
\indent\indent \texttt{-w} ~	counts number of words.\\ 
\indent\indent \texttt{-c} ~	counts number of characters.\\
\texttt{\$ wc -l *.pdb > file.txt} ~	 redirect output to a file (because shell cannot print output on the screen) and erase the content of the file.txt. \\
\texttt{>>} ~	redirects output to a file by appending to the existing content without erasing it. It's different from ">".\\
\texttt{\$ cat file.txt} ~ displays content of the file, all at once.\\
\texttt{\$ less file.txt} ~	shows content but stops when screen is full. Go forward with spacebar, b, q. \\
\texttt{\$ tail -2 animals.txt >> animalsUpd.txt} ~	adds last two items of the list to the file.\\
\texttt{\$ sort Letters.txt} ~  sorts in alphabetical order, without changing original file, shows output on the screen.\\
\texttt{\$ sort -n number.txt} ~	sorts in numerical order.\\
\texttt{\$ sort -n number.txt > sorted-number.txt} ~ redirects the result to second file.\\
\texttt{\$ head -n 1 number.txt} ~ shows the first line of the file on the screen.\\
\texttt{\$ tail -n 3 number.txt} ~ shows the last 3 lines of the file on the screen.\\
\texttt{\$ sort -n length.txt | head -n 1} ~  executes the left command first, then using that file as input to execute command on the left. Result: it sorts in numberical order, then displays on the screen the first line.\\
\texttt{\$ wc -l} ~ 	allows you to enter texts. ctrl-D to finish.\\
\texttt{\$ uniq} ~ removes adjacent duplicated lines.\\
\texttt{\$ cut -d , -f 2 file.txt} ~ cuts out sections of each line of a file.\\
\subsubsection{\small\textsl{How to write a loop and shell scripts }}
\texttt{Loop 1}
\begin{lstlisting}
$ for filename in document1.txt document2.txt
>do
>    head -n 3 $filename
>done
\end{lstlisting}
This is a typical loop structure. The word \texttt{for} is the repeat command. The operation finds the first 3 lines of the file. This loop will do this operation for document 1 and 2. The word \texttt{\$ filename} is just a variable; it could have been any word.\\
\\
\texttt{\$ echo} ~ prints the ouptput on the screen.\\
\texttt{\$ history | tail -n 5} ~ shows history of the last 5 commands.\\
\texttt{\$ history | tail -n 5 > recent.sh} ~ save the last 5 commands in nano.\\
\texttt{\$ !123} ~ enter number of the line you want from history. \\
\texttt{\$ !!} ~ shows your last command.\\
\texttt{\$ !\$} ~ retrieves last words of the last commands.\\
\texttt{\$ nano newfile.sh} ~ creates a new file in text editor nano, which runs within the shell. This is where we write Shell script, then run the script in Unix.\\
\\
In nano:\\ 
\indent\texttt{head -n 15 octane.pdb | tail -n 5}\\
\indent we could also use nano to write a script by typing a command as such. \\
\\
\texttt{\$ bash newfile.sh} ~ it runs the script written in bash.\\
\\
In nano:\\
\indent\texttt{head -n 15 \$1 | tail -n 5}\\
\indent this has the same result as the above nano script because \texttt{\$1} means the first filename on the command line. \\
\\
In nano:\\
\indent \texttt{head -n \$2 \$1}\\
\indent again \$2 is a position variable, which indicates second command-line argument.\\

\subsubsection{\small\textsl{How to find something in a text }}
\texttt{\$ grep not document.txt} ~ finds and prints lines in this document that has the word "not".\\
\texttt{\$ grep The document.txt} ~ finds and prints lines that contains the word "The" but also words like "Thesis".\\
\texttt{\$ grep -w The document.txt} ~ limits word boundary. It limits the search to only "the" and words like "thesis" will not appear.\\ 
\texttt{\$ grep -w "is not" document.txt} ~ finds and prints lines that contains multiple words. \\
\texttt{\$ grep -n "it" document.txt} ~ finds and prints lines that contain any words with "it", such as \textbf{it}, w\textbf{it}h.\\
\texttt{\$ grep -n -w "the" document.txt}  ~ finds lines that contain "the" and prints also the number of the line where "the" is found.\\
\texttt{\$ grep -n -w -i "the" document.txt} ~ the flag \texttt{-i} means case-insensitive.\\
\texttt{\$ grep -n -w -v "the" document.txt} ~ where \texttt{-v} is to invert the search, meaning lines that do not contain the word "the".\\
\texttt{\$ man grep} ~ manual, shows many other flags of \texttt{grep} (Mac). Use \texttt{q} to exit/esc.\\ 
\texttt{\$ grep -E "\textasciicircum.o" document.txt} ~ finds lines that contain an 'o' in the second position, such as t\textbf{o}ner, s\textbf{o}ftware. The \texttt{-E} flag looks for pattern that is called \textbf{regular expression}. We put the pattern in quotation to prevent the shell trying to interpret it. The \texttt{\textasciicircum} finds the match to the start of the line. The . can be any character (just like ? in the shell), and "o" matches the letter "o". \\
\texttt{\$ find .} ~ is similar to the command \texttt{ls} in Unix. Again, \texttt{.} means the current working directory, where the search will take place. \texttt{find} will list every file and directory under the current working directory.\\
\texttt{\$ find . -type d} ~ finds things that are directories. Here it doesn't list things in any order.\\
\texttt{\$ find . -type f} ~ finds all that are files.\\
\texttt{\$ find . -name *.txt} ~ find files ends with \texttt{txt} but only those saved in this directory and not in the subdirectories. \\
\texttt{\$ find. -name '*.txt'} ~ finds \texttt{txt} files in this directory and the subdirectories. So here \texttt{*} acts as a true wildcard.\\
 
\subsection{\textbf{Shortcuts}}
\texttt{Ctrl+Z} ~ works as esc.\\
\texttt{Tab}	 ~	autocompletion, revisit the most recent commands use. Avoid re-typing a command, saves time.\\
\texttt{Up\&Down keyboard arrows} ~ show previous commands typed.\\
\texttt{spacebar} ~	forward one page.\\
\texttt{b} ~	 backward one page.\\
\texttt{q} ~	 quit.\\
\\
In nano:\\
\indent
\texttt{Ctrl+O} ~ "writing out", saves the file. \\
\indent
\texttt{Enter, Ctrl+X} ~ to exit nano back to Unix (Mac).\\

\newpage
\section{Python}


Principles of Python:
\begin{itemize}
\item[]Beautiful is better than ugly.
\item[]Explicit is better than implicit.
\item[]Simple is better than complex.
\item[]Complex is better than complicated.
\item[]Readability counts.

\hfill Excerpts from \textit{Zen of Python} 
\end{itemize}

Python programming language was created by Guido van Rossum in 1991. Python's minimalist philosophy emphasizes on readability and fun to use, hence the name as a tribute to \textit{Monty Python}. Therefore, code that is hard to understand is \textit{unpythonic}.\\
\\
 It is an open source software that uses dynamic typing. In programming languages, a type system is a set of rules that assigns a property called type to the various constructs of a computer program, like variables, expressions, functions or modules. \\
\\
 Python codes can be run either via an interpreter or within a shell script (Mac). Here, \textbf{Jupyter Notebook} is used. 

\subsection{\textbf{Definitions}}
\texttt{Jupyter Notebook} ~ allows python codes to be executed.It can also become committed for version control repositories like github. Markdown can be used to generate a notebook environment for writing and developing code. \\
\\
\texttt{kernel} ~ is the computational engine. \\ 
\\
\texttt{string} ~ is data in the form of text. A string is a series of letters, numbers or symbol connected in order like a string.
\texttt{interger} ~ 
\texttt{float} ~
\texttt{variables} ~ are numbers which are stored for later use. \\
\\
\texttt{Boolean} ~ is a data type that can either be true or false, intended to represent the two truth values of logic. \\
\\
\texttt{data type} ~ can be numbers and Booleans.\\
\\
\subsection{\textbf{Symbols}}
\texttt{In [~]} ~ means number of input, for tracking purpose.//


\subsection{\textbf{Shortcuts}}
In Jupyter notebook:\\
\indent{\texttt{A} ~ inserts a new cell above the current cell.}\\ 
\indent{\texttt{B} ~ inserts a new cell below.}\\
\indent{\texttt{Ctrl-Enter} ~ runs the cells.}\\
\indent{\texttt{M} ~ changes the current cell to Markdown.}\\
\indent{\texttt{Y} changes Markdown back to code mode.\\
\indent{\texttt{D+D} (pressing the key twice) deletes the current cell.\\

\subsection{Commands}
From the Terminal, type:\\
\texttt{jupyter notebook} ~ to launch the Jupyter Notebook App.\\
\\
From Jupyter Notebook, click:\\
 on menu \texttt{File}, then \texttt{Close and Halt} ~ to shut down a kernel.\\
\\
The following commands are taken place in Jupyter Notebook:\\
\\
In [1]: \fbox{\parbox{120}{%
\texttt{print ("hello world")}
}}\\
prints \texttt{hello world} as the output.\\
\\
In [2]: \fbox{\parbox{120}{%
\texttt{my\_variable=10}\\
\texttt{print (my\_variable)}
}}\\
output will be 10. Variables are numbers which are stored for later use.\\
\\
In [3]: \fbox{\parbox{120}{% 
\texttt{my\_int = 7}\\
\texttt{my\_float = 1.23}\\
\texttt{my\_bool = True}\\
\\
\texttt{print (my\_int)}\\
\texttt{print (my\_float)}\\
\texttt{print (my\_bool)}
}}\\
Output: 7, 1.23, True.\\ 
\\
In [4]: \fbox{\parbox{120}{%
\texttt{my\_int = 3}
}}\\
when retyping a variable, it will get reassigned to the new value, in this case 3. \\

\newpage
\section{Markdown}
It is a markup language with plain text formatting syntax. It is an easy-to-read, easy-to-write plain text format, contrary to markup language (Rich Text Format or HTML), which is marked up with tags and formatting instructions. It can be easily converted into HTML. \\
\\
Markdown is a way to style text on the web. It uses \# or * to format the document words  in bold, italic, or creating lists. 
The document written in Markdown has the file extension of \texttt{.md}. In this internship, Markdown was used to keep notes on the daily computation progress and Python codes via Jupyter Notebook. 

\subsection{Commands}
From Jupyter Notebook drop-down menu, choose:\\
1 - \texttt{code} ~ to begin writing plain text.\\
2 - \texttt{Markdown} ~ to mark as Markdown.\\
3 - click \texttt{run cell} or Ctrl+Enter ~ to convert into plain text.\\
\\
Headers:\\
\texttt{\#} ~ huge size and in bold.\\
\texttt{\#\#} ~ big size and in bold.\\
\texttt{\#\#\#\#\#\#} ~ small size.\\
\\
Emphasis:\\
\texttt{*Text will be italic*}\\
\texttt{\_This will also be italic\_}\\
\\
\texttt{**Text will be bold**}\\
\texttt{\_\_This will also be bold\_\_}\\
\\
\texttt{\_You **can** combine them\_}\\
\\
Lists using bullets\\
\texttt{*Item 1}\\
\texttt{*Item 2}\\
\indent * Item 2a\\
\indent * Item 2b\\
\\
Lists using numbers\\
\texttt{1. Item 1}\\
\texttt{1. Item 2}\\
\texttt{1. Item 3}\\
\indent \texttt{1. Item 3a}\\
\indent \texttt{1. Item 3b}\\
\\
Spaces between letters:\\
\texttt{\&nbsp;\&nbsp;\&nbsp;\&nbsp;\&nbsp;\&nbsp;} \\
\\

\newpage
\section{Emacs}
Emacs is one of the most popular and powerful text editors. It offers much longer lists of commands than other UNIX-based text editors and the ability to extend the interface. Here, GNU/Emacs is used. All GNU (GNU is Not Unix) software has this prefix. \\
\\
The configuration file for emacs is \texttt{init.el}. 

\subsection{Symbols}
\texttt{C} ~ stands for \texttt{control} in the keyboard.

\subsection{Commands}
From Unix shell:\\
1 - \texttt{\$ echo pandoc -o file.pdf inputFile}\\
2 - \texttt{\$ evince file.pdf} ~ converts emacs file to pdf.\\
\\
\texttt{C-z} ~ suspend Emacs.\\
\texttt{C-x C-c} ~ exit Emacs permanently.\\
\texttt{C-x C-f} ~ read a file into Emacs.\\
\texttt{C-x s} ~ save all files.\\
\texttt{M-x} ~ to install packages. \\

\newpage
\section{Secure Shell (SSH)}

SSH is to gain access to another computer/server with greater computational capacity and execute programs there. The first step is to log in to that computer, called remote login, using passwords. Then, the commands are passed to a shell running on the remote computer. That shell runs our commands and send back output to my computer. \\
\\
The tool we use to log in remotely is the secure shell, or SSH. By entering name of computer and password, we could connect remotely. In order to avoid typing the passwords over and over again, SSH key was created to tell the remote computer that it should always trust us. \\
\\
To accomplish this, a secure login must be established. This is done by a cryptographic network protocol. SSH keys come in pairs, a \textbf{public key} that gets shared with services like Github, and a \textbf{private key} that is stored in my computer. If the keys match, then access is granted. \\
\\
In other words, SSH uses public-key cryptography to authenticate  the remote computer and allow it to authenticate the user. This is done only ONCE. Furthermore, the cryptography behind SSH keys ensures that no one can reverse engineer my private key from the public one. Here, SSH is used to log on Github.\\


\subsection{Commands}
\subsubsection{How to connect remotely}
1 - From the Terminal:\\
\texttt{\$ ssh username@computer} ~ connects to the remote computer specified, followed by entering a password.\\
\texttt{Ctrl-D} ~ terminates the remote login and returns to our shell. \\
\subsubsection{How to generate SSH key}
1 - In the Terminal:\\
\texttt{\$ ssh-keygen -t rsa -b 4096 -C "my\_email\@address.com"} ~ this creates a new ssh key.\\
2 - \texttt{Generating public/private rsa key pair} ~ this lines appears next. \\
3 - \texttt{Enter a file in which to save the key (/User/Sistina/.ssh/id\_rsa.} ~ press Enter, this accepts the default file location.\\
4 - You will see the key's randomart image. \\
\includegraphics[scale=0.5]{randomart}\\
\\
5 - In the Terminal:\\
\texttt{\$ cd .ssh/} ~ this goes into the directory of SSH.\\
6 - In the Terminal: \\
\texttt{\$ ls} ~ you should see id\_rsa and id\_rsa.pub as listed.\\
7 - type:
\texttt{\$cat *} ~ it will list the content of Private key and and the public key.\\ 
\\
\includegraphics[scale=0.5]{private_key}\\


\newpage
\section{Git}
Git is a version control system for tracking changes in my source code history. Github is a hosting service for Git repositories. So they are not the same thing: Git the tool, Github the serivce projects that use Git. \\
\\
Once uploaded onto Github, the file can be edited by selected collaborators, creating a collaboration platform among multiple users. \\
\\
Git thinks of its data like a series of snapshots of a miniature filesystem. Every time we commit, Git takes a picture of the file at that moment, and stores that snapshot. If the file is not further modified, Git doesn't store the file again, just a link to the previous identical file it has stored. Git thinks of its data like a \textbf{stream of snapshots}.\\
\\
Git has three main states that the file can reside in: \textit{committed, modified,} and \textit{staged}:
\begin{itemize}
  \item committed means that the data is stored in my local database.
  \item modified means that I have changed the file but have not committed it to my database yet.
  \item staged means that you have marked a modified file in its current version to go into the next commit snapshot. 
\end{itemize}
\\
This leads to the three main sections of a Git project: the Git directory, the working tree, and the staging area.\\
\includegraphics[scale=0.3]{git_3sections}\\
\begin{itemize}
  \item Git directory is where Git stores the metadata and object database of my project. This is the most important part of Git, and it is what is copied when I \textit{clone} a repository from another computer.
  \item working tree is a single checkout of one version of the project. These files are pulled out of the compressed database in the Git directory and placed on disk so I could modify or continue to work on. 
  \item staging area is a file, generally contained in the Git directory, that stores information about what will go into my next commit. 
\end{itemize}
\\
The basic Git workflow goes as follows:
\begin{enumerate}
  \item I modify files in the working tree.
  \item I selectively stage just those changes I want to be part of the next commit, which adds only those changes to the staging area.
  \item I commit, which takes the files as they are in the staging area and stores that snapshot permanently to the Git directory. 
\end{enumerate}
\\
Therefore, if a version of file is in the Git directory, it is committed. If it was modified and added to the staging area, it is staged. And if it was changed since it was checked out but has not been staged, it is modified. \\
\\
The lifecycle of the stutus of a file looks like this:\\
\includegraphics[scale=0.4]{git_lifecycle}\\
Git directory is created by \texttt{\$git init}, and it is folder that contains all the informations needed for git to work. The \texttt{. git} directory looks like this:\\
\includegraphics[scale=0.5]{git_directory}\\
\\
Once
\To set up GitHub, first step is to sign up for an account on GitHub.com. Then install Git on local computer. Github won't work if Git is not installed. Git uses the Terminal to access it. \\ 
\subsection{Definitions}
\texttt{version control} ~ means it keeps "snapshots" of every point in time in the project's history, without being overwritten, as whenever we save in Microsoft Word file.\\
\\
\texttt{repo (for repository)} ~ is a virtual storage space of my project. \\
\\
\texttt{commit} ~  saves the state of the project, taking a "snapshot" of the repo at a point in time.\\
\\
\texttt{branch} ~ this allows multiple collaborators working on a project at the same time without Git getting them confused. There is a hierarchy: the main version is called the "master"; each user "branch off" to work on their own versions. Once it's done, the sub-branches "merge" with the "master". \\


\subsection{Adding a new SSH key to Github}
This step allows a secure and hussle-free authentication process whenever we connect to Github. 
1 - From the Terminal:\\
\texttt{\$ pbcopy < ~/.ssh/id\_rsa.pub} ~ copies the content of the SSH public key to the clipboard. \\
2 - From the github website, click "your profile photo", then click \textbf{Settings}.\\
3 - Click \textbf{SSH and GPG keys}.\\
4 - Click \textbf{New SSH key} or \textbf{Add SSH key}.\\
5 - Paste the key into the "Key" field.\\
6 - Click \textbf{Add SSH key}.\\

\subsection{Commands}
\subsubsection{How to configure Git}

1 - Install Git (Xcode Command Line Tool for Mac). \\
From the Terminal:\\
2 - \texttt{\$ git --version} ~ checks if git is present.\\
3 - \texttt{git config --global user.name "Your Name Here"} \\
4 - \texttt{git config --global user.email "YourAddress@mail.com}\\

\subsubsection{How to create and save a repo}

1 - Login to Github account, click on the \texttt{+} sign on the right top menu, select \texttt{New repository}.\\
2 - Give the repo a short, memorable name plus description. \\
3 - Select for public or private viewing.\\ 
4 - Click \texttt{Create repository} ~ now we have created an online space for my project to live in. \\
5 - Click \texttt{Clone or download} ~ so far, we have created a \textit{remote} repository. By cloning the repository, this creates a \textit{local} copy on my computer and sync between the two locations.\\
6 - Choose \texttt{Clone with SSH} and click the icon to copy the clone URL for the repository.\\
On my computer:\\
7 - Place the file to be pushed together with .git in the same folder.\\
From the Terminal:\\
8 - \texttt{\$ git init} ~ initializes a new Git repository. This is a one-time command during initial setup of a new repo.\\
9 - \texttt{\$ git clone} ~ and paste the URL copied from the clone and press Enter. For example: \\
\\
\includegraphics[scale=0.5]{git_clone}\\
\\
10 - \texttt{\$ git add F1.tex} ~ F1.tex is an example of files in LaTex. This command brings a new file to Git's attention. After adding a file, it is included in Git's "snapshots" of the repo.\\
11 - \texttt{\$ git commit -m} ~ is the most important command. It takes a "snapshot" of the repo. This command is followed by "description", meaning what changes were made. For example: \\
\\
\includegraphics[scale=0.5]{git_commit}\\
\\
12 - \texttt{\$ git push} ~ this makes my commits visible online on Github. I "push" the changes up to GitHub. \\
\\
\includegraphics[scale=0.5]{git_push}\\
\\
Now the file F1.tex is stored in Github.

\subsubsection{Viewing staged and unstaged changes}
\texttt{\$ git status} ~ tells us if the file is committed or not. For example:\\
\includegraphics[scale=0.5]{git_status}\\
"Changes not staged for commit" means that this file has been modified in the working directory but not yet staged. (To stage it, we need to run \texttt{\$ git add}, which begins to track new files, to stage files. \\
If we run \texttt{\$ git add}, the message will be "Changes to be committed". Now the file is staged and ready to be committed.\\ 
Note: Suppose I make some changes at this point, and then run \texttt{\$ git status}. I will get both messages: "Changes to be committed" and "Changes not staged for commit". If I commit now, Git will save the version when I ran \texttt{\$ git add}, but not the modifications I did after that. So the next step is to run again \texttt{\$ git add} to stage the latest version of the file.\\
\\
\texttt{\$ git diff} ~ very detail description of which modifications were made that are still unstaged. If the changes were staged (\texttt{\$ git add}) then, \texttt{git diff} will not give any output. \\
\\
\texttt{\$ git log} ~ lists the author that 

\subsubsection{others}
\texttt{\$ git help} ~ shows common git commands. \\
\texttt{\$ git rm} ~ removes a file from Git by removing it from the staging area, and then commit. It also removes the file from the working directory, so it doesn't appear as an untracked file. 


\newpage
\section{Exercises}

\newpage
\section{References}
\begin{document}


https://en.wikipedia.org/w/index.php?title=Type\_system\&oldid=849096813 
\end{document}


\end{document}